# 整体架构
# 商品列表展示
## 建表
1. item，即商品表，属性有商品id、商品名、商品代码、商品总库存、商品买入时间、是否在售、创建时间、更新时间
2. item_kill，即待秒杀商品表，属性有秒杀id、商品id、秒杀数目、秒杀开始时间、秒杀结束时间、是否有效、创建时间
3. item_kill_success，即秒杀成功表，属性有，订单号、商品id、秒杀id、用户id、订单状态、创建时间
4. user，即用户表，属性有用户id、用户名、密码、手机号、邮箱、是否有效、创建时间、更新时间
## 前端展示
列出秒杀表的商品信息，对剩余数量大于0且处于秒杀时间段内的商品使用cankill字段选择商品显示的时候是否可被秒杀
# 整体流程
## 用户登录
登录界面->进行登录->校验通过则进入秒杀业务
## 列表展示
读取kill表的数据，若剩余数量大于0且当前时间处于秒杀时间段，则cankill字段为1，拥有进入商品详情的按钮，否则为灰色
## 秒杀请求
1. 点击秒杀按纽
2. 将用户id和秒杀id存进dto对象传给后端
3. 进入秒杀Controller，判断传入数据是否合法
4. 合法则进入KillService，传入的是秒杀id与用户id
5. 基于redis分布式锁的订单生成
6. 通过秒杀id与用户id判断当前用户是否秒杀过了，就是在mysql查询订单表中是否有某订单同时拥有一样的用户id与秒杀id，若秒杀过则返回已购买过该商品
7. 构造key，通过秒杀id和用户id+"-RedisLock"生成key
8. 构造value，没有实际含义，只是为了存储key,且释放锁的时候通过value判断
9. 设置锁，通过setnx设置锁，返回该锁是否存在(有效)
10. 若有效，即锁住了，设置30s后释放锁
11. 通过秒杀id查询秒杀商品的详情存进对象
12. 若返回的对象部位null，且可被秒杀则更新库存
13. 更新过程为，若该商品库存大于0则将库存减1，返回的是被影响的行数
14. 若更新成功，即影响行数大于0，则进入订单生成流程，否则秒杀失败
15. 订单生成流程传入的是用户id与秒杀商品的详情对象
16. new一个存订单的对象，使用雪花算法生成订单号，给该对象赋值，即订单号，用户id，商品id，秒杀id，设置订单状态为0，创建时间
17. 将该订单对象插入到订单表中，返回影响行数
18. 若插入成功则将订单号放入rabbitMQ的异步邮件消息通知队列和死信队列
19. 在使用redis进行分布式锁实现的KillService的finally中判断设置的value与通过getkey得到的value是否相等，是则删除该键

# 分布式锁
## redis实现
在整体流程那说过了
## 基于redisson
1. 传入用户id与秒杀id
2. 通过秒杀id与用户id+一些字符串生成对应的key
3. 通过redissonClient.getLock(key)获得对应的锁，得到锁对象lock
4. 通过lock.tryLock(),人性化时间，可重入，30s尝试，获取锁后10s释放，返回布尔值
5. 如果为true，则判断当前用户是否购买过该商品
6. 若没有，则通过秒杀id获取对应的秒杀商品详情对象
7. 判断是否可被秒杀
8. 扣减库存
9. 订单生成
10. 释放锁
## 基于zookeeper
1. 定义一个路径"/kill/zkLock/"
2. 进程之间的互斥操作锁 new InterProcessMutex(curatorFramework, pathPrefix + killId + userId + "-lock")
3. 获取该锁尝试等待10s
4. 相同操作
5. 释放

是路径上不断创建临时有序节点，谁创的节点最小即获取到锁，最小序号节点操作完成了就释放锁，该下一个序号节点获取锁，保证串行

# rabbitMQ
队列+交换机+路由
## 邮件发送过程
### 进入消息队列
RabbitSenderService
1. 传入的是订单号
2. 通过订单号查询订单信息，如果不为null则进入下一步
3. 设置发送消息逻辑为Jackson2JsonMessageConverter(传输格式)，设置交换机为mq.kill.item.success.email.exchange，设置对应的路由，即可将消息发到指定队列
4. 将消息持久化，发送到消息队列
### 消费消息
RabbitReceiverService
1. 在消费方法上@RabbitListener，并指定对应的队列和自己定义的消费者模式
2. 将队列中的订单信息提取出来，与模板进行format，设置邮件内容，进行发送

## 死信队列
在config中配制交换机+路由+队列的绑定
1. 等待着一定时间失效超时未支付的订单，延迟处理指定的消息，隔指定时间被消费者消费
2. 基本同邮件发送过程，不过是不同的交换机，路由和队列，发送到
3. 设置TTL，超过设置的时间就将死信队列的消息放到真正的死信队列中
### 未超时的订单
利用死信队列进行超时未支付订单的失效
生产者将消息放到基本交换机+基本路由的死信队列，同时有我们设定的死信交换机+死信路由+TTL存活时间，同时绑定该死信队列
在该死信队列的消息超过了TTL，就会将消息发送到与死信交换机和死信路由真正绑定的队列中去被消费者消费
1. 在消费方法上@RabbitListener，并指定对应的队列(未超时的订单队列)和自己定义的消费者模式
2. 超时订单是通过设置的TTL进行实现
3. 若订单到时间了，那么就消费者就可以消费
4. 通过从队列中获取的订单详情，通过订单号查找该订单在数据库中的详情，如果是未支付，则将其改为失效-1

# 一些知识
## redisson
1. 基于redis的驻内存网络数据库
2. 提供的功能不仅包含redis所提供的，还提供了注入延迟队列，分布式服务，多种分布式对象等
3. 亲民，基于Javase核心知识体系中的数据结构提供服务，面向redis实现
